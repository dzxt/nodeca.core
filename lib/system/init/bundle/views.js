// `views` section processor
//


'use strict';


// stdlib
var fs    = require('fs');
var path  = require('path');


// 3rd-party
var _       = require('lodash');
var async   = require('async');
var fstools = require('fs-tools');


// internal
var stopwatch     = require('../utils/stopwatch');
var engines       = require('./views/engines');


////////////////////////////////////////////////////////////////////////////////


//  writeClientViews(filename, views[, namespace], callback(err)) -> String
//  - filename (String): Filename where to write built views tree.
//  - views (Object): Views map generated by [[Views.collect]].
//  - namespace (String): Global object used as container for the tree.
//  - callback (Function): Executed once everything is done.
//
//  Build client-side `views` tree populator and writes it into the `filename`
//  creating parent directories if needed.
//
//
//  ##### Example
//
//      collect('/path/to/views', function (err, views) {
//        // ...
//        writeClientTree('/path/to/client.js', views, function (err) {
//          // ... syntax sugar is sweet ...
//        });
//      });
//
function writeClientViews(filename, views, namespace, callback) {
  if (!callback) {
    callback  = namespace;
    namespace = null;
  }

  if (!namespace) {
    namespace = 'this.views';
  }

  fstools.mkdir(path.dirname(filename), function (err) {
    var result = '';

    if (err) {
      callback(err);
      return;
    }

    result += '(function () {\n';

    _.forEach(views, function (code, apiPath) {
      result += '  this[' + JSON.stringify(apiPath) + '] = (' + code + ');\n';
    });

    result += '}).call(' + namespace + ' || (' + namespace + ' = {}))';

    // Done.
    fs.writeFile(filename, result, 'utf8', callback);
  });
}


function processViews(N, outfile, config, callback) {
  var serverViews = {}
    , clientViews = {};

  async.forEachSeries(config.files, function (pathname, next) {
    var str;

    try {
      str = pathname.readSync();
    } catch (err) {
      next(err);
      return;
    }

    async.parallel([
      function (next) {
        // compile server-side views (functions)
        engines[pathname.extname].server(str, {
          filename: String(pathname)
        }, next);
      },
      function (next) {
        // compile client-side views (string sources of functions)
        engines[pathname.extname].client(str, {
          filename: String(pathname)
        }, next);
      }
    ], function (err, results) {
      if (results) {
        serverViews[pathname.apiPath] = results[0];
        clientViews[pathname.apiPath] = results[1];
      }

      next(err);
    });
  }, function (err) {
    if (err) {
      callback(err);
      return;
    }

    // Inject server views table.
    _.extend(N.views, serverViews);

    // Write client-side views table.
    writeClientViews(outfile, clientViews, 'this.N.views', callback);
  });
}


////////////////////////////////////////////////////////////////////////////////


module.exports = function (sandbox, callback) {
  var N = sandbox.N
    , tmpdir = sandbox.tmpdir
    , config  = sandbox.config
    , timer   = stopwatch()
    , outdir  = path.join(tmpdir, 'views');

  N.views = {};

  try {
    fstools.mkdirSync(outdir);
  } catch (err) {
    callback(err);
    return;
  }

  async.forEachSeries(_.keys(config.packages), function (pkgName, next) {
    var
    viewsConfig   = config.packages[pkgName].views,
    viewsOutfile  = path.join(outdir, pkgName + '.js');

    if (!viewsConfig) {
      next();
      return;
    }

    processViews(N, viewsOutfile, viewsConfig, next);
  }, function (err) {
    N.logger.info('Processed views section %s', timer.elapsed);
    callback(err);
  });
};
