// `views` section processor
//


'use strict';


// stdlib
var fs    = require('fs');
var path  = require('path');


// 3rd-party
var _       = require('lodash');
var async   = require('async');
var fstools = require('fs-tools');


// internal
var stopwatch     = require('../utils/stopwatch');
var expandTree    = require('../utils/expand_tree');
var engines       = require('./views/engines');


////////////////////////////////////////////////////////////////////////////////


//  buildClientTree(views[, namespace = 'this.views']) -> String
//  - views (Object): Views map generated by [[Views.collect]].
//  - namespace (String): Global object used as container for the tree.
//
//  Returns a browserified function that will create views tree and will
//  inject it into the `namespace`.
//
//
//  ##### Example
//
//      collect('/path/to/views', function (err, views) {
//        // ...
//        var output = buildClientTree(views, 'this.appViews');
//        fs.writeFile('/path/to/client.js', output);
//        // ...
//      });
//
function buildClientTree(viewsTree, namespace) {
  namespace = namespace || 'this.views';

  var body = [];

  //
  // generate tree population with functions
  //

  _.each(viewsTree, function (view, api) {
    body.push('this[' + JSON.stringify(api) + '] = ' + view.client);
  });

  //
  // Return tree populator
  //

  return '(function () {\n' +
         body.join('\n') +
         '\n}).call(' + namespace + ' || (' + namespace + ' = {}));';
}


//  writeClientTree(filename, views[, namespace], callback(err)) -> String
//  - filename (String): Filename where to write built views tree.
//  - views (Object): Views map generated by [[Views.collect]].
//  - namespace (String): Global object used as container for the tree.
//  - callback (Function): Executed once everything is done.
//
//  Build client-side `views` tree populator and writes it into the `filename`
//  creating parent directories if needed.
//
//
//  ##### Example
//
//      collect('/path/to/views', function (err, views) {
//        // ...
//        writeClientTree('/path/to/client.js', views, function (err) {
//          // ... syntax sugar is sweet ...
//        });
//      });
//
function writeClientTree(filename, tree, namespace, callback) {
  if (!callback) {
    callback  = namespace;
    namespace = null;
  }

  fstools.mkdir(path.dirname(filename), function (err) {
    var str;

    if (err) {
      callback(err);
      return;
    }

    try {
      str = buildClientTree(tree, namespace);
    } catch (err) {
      callback(err);
      return;
    }

    fs.writeFile(filename, str, 'utf8', callback);
  });
}


function processViews(N, outfile, config, callback) {
  var viewsTree = {};

  async.forEachSeries(config.files, function (pathname, next) {
    var str;

    try {
      str = pathname.readSync();
    } catch (err) {
      next(err);
      return;
    }

    async.parallel([
      function (next) {
        // compile server-side views (functions)
        engines[pathname.extname].server(str, {
          filename: String(pathname)
        }, next);
      },
      function (next) {
        // compile client-side views (string sources of functions)
        engines[pathname.extname].client(str, {
          filename: String(pathname)
        }, next);
      }
    ], function (err, results) {
      // expose compiled data into the tree
      results = results || [];

      viewsTree[pathname.apiPath] = {
        server: results[0],
        client: results[1]
      };

      next(err);
    });
  }, function (err) {
    if (err) {
      callback(err);
      return;
    }

    // Inject server tree
    _.each(viewsTree, function (render, api) {
      N.views[api] = render.server;
    });

    expandTree(N.views);

    // write client-side views tree
    writeClientTree(outfile, viewsTree, 'this.N.views', callback);
  });
}


////////////////////////////////////////////////////////////////////////////////


module.exports = function (sandbox, callback) {
  var N = sandbox.N
    , tmpdir = sandbox.tmpdir
    , config  = sandbox.config
    , timer   = stopwatch()
    , outdir  = path.join(tmpdir, 'views');

  N.views = {};

  try {
    fstools.mkdirSync(outdir);
  } catch (err) {
    callback(err);
    return;
  }

  async.forEachSeries(_.keys(config.packages), function (pkgName, next) {
    var
    viewsConfig   = config.packages[pkgName].views,
    viewsOutfile  = path.join(outdir, pkgName + '.js');

    if (!viewsConfig) {
      next();
      return;
    }

    processViews(N, viewsOutfile, viewsConfig, next);
  }, function (err) {
    N.logger.info('Processed views section %s', timer.elapsed);
    callback(err);
  });
};
