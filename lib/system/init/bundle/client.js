// `client` section processor
//


'use strict';


// stdlib
var fs    = require('fs');
var path  = require('path');


// 3rd-party
var _            = require('lodash');
var fstools      = require('fs-tools');
var findRequires = require('find-requires');


// internal
var stopwatch         = require('../utils/stopwatch');
var resolveModulePath = require('./utils/resolve_module_path');
var findPaths         = require('./utils/find_paths');


////////////////////////////////////////////////////////////////////////////////

// wrapper for client's module (widget)
var wrapper_widget_template_path = path.join(__dirname, 'client', 'wrapper_widget.tpl');
var wrapper_widget_template = _.template(fs.readFileSync(wrapper_widget_template_path, 'utf8'));

// wrapper for common.js module
var wrapper_require_template_path = path.join(__dirname, 'client', 'wrapper_require.tpl');
var wrapper_require_template = _.template(fs.readFileSync(wrapper_require_template_path, 'utf8'));

// wrapper for json files
var wrapper_require_json_template_path = path.join(__dirname, 'client', 'wrapper_require_json.tpl');
var wrapper_require_json_template = _.template(fs.readFileSync(wrapper_require_json_template_path, 'utf8'));

// wrapper for alias to common.js module
var wrapper_alias_template_path = path.join(__dirname, 'client', 'wrapper_alias.tpl');
var wrapper_alias_template = _.template(fs.readFileSync(wrapper_alias_template_path, 'utf8'));


var vendorModules; // Bundled vendor files paths (should be embedded only once)
var clientModules; // Global list if wiget's JS - 'not requireable'
var vendorVirtualModules; //  { Alias name -> file path }
var embeddedModulesPaths; // { pgkName -> { paths: true }}

////////////////////////////////////////////////////////////////////////////////


/*
 * Wraps the given source code string as a module definition for the client.
 * Recursively browserifies and embeds all of unbundled dependencies.
 *
 * options:
 *
 * - wrapper  - src wrapper (client/require), or empty (for main.js)
 * - apiPath  - api path, for flient only
 * - fsPath   - current file name
 * - allowEJS - used only for `main.js`, to inject some variables in <file>.js.ejs
 */
function browserifySingle(sandbox, pkgName, source, options) {
  var result       = [],
      wrapper      = options.wrapper,
      apiPath      = options.apiPath || null,
      filePath     = options.fsPath,
      directory    = path.dirname(filePath),
      dependencies = [],
      root         = sandbox.N.mainApp.root;

  if (!filePath) {
    throw new Error('Missed required `fsPath` argument.');
  }

  // Find & reqursuvely process `require` directives
  //
  findRequires(source, { raw: true }).forEach(function (match) {
    var resolvedPath, dependencySource, relativePath, ext;

    // `require` path cannot be determinated - throw error.
    if (!match.value) {
      throw new Error('Error in \'require\': file \'' + filePath + '\', string ' + match.line + '.');
    }

    if (vendorVirtualModules[match.value]) {
      // Get path to a virtual module.
      resolvedPath = vendorVirtualModules[match.value];
    } else {
      // Resolve absolute, relative, or node-module path.
      resolvedPath = resolveModulePath(directory, match.value);
    }

    if (!resolvedPath) {
      throw 'Bundler cannot find required file "' + match.value + '" ' +
            'at ' + filePath + ':' + match.point + ':' + match.line;
    }

    if (_.has(clientModules, resolvedPath)) {
      throw 'Require of client block "' + match.value + '" is prohibited ' +
            'at ' + filePath + ':' + match.point + ':' + match.line;
    }

    relativePath = path.relative(root, resolvedPath);

    // Note: This is not actually safe way to replace `require` paths, but
    // alternative ways seem be too complicated. In real live that should
    // work without problems.
    source = source.replace(match.raw, JSON.stringify(relativePath));

    dependencies.push(relativePath);

    // Embed private local modules. (not described in the bundle config and
    // not embedded yet)
    if (!_.has(vendorModules, resolvedPath) &&
        !_.has(embeddedModulesPaths[pkgName], resolvedPath)) {

      embeddedModulesPaths[pkgName] = embeddedModulesPaths[pkgName] || {};
      embeddedModulesPaths[pkgName][resolvedPath] = true;

      // `required` files in vendor modules must be marked as vendor's too
      if (_.has(vendorModules, filePath)) {
        vendorModules[resolvedPath] = true;
      }

      dependencySource = fs.readFileSync(resolvedPath, 'utf8');

      // Kill sourcemap directives, that can be generated by coffescript.
      // They can make browser to do wrong requests.
      // Example - `performance-now` module
      dependencySource = dependencySource.replace(/^\/\/@ sourceMappingURL/mg, '//-@sourceMappingURL');

      ext = path.extname(resolvedPath).toLowerCase();

      // Recursively browserify
      result.push(browserifySingle(sandbox, pkgName, dependencySource, {
        wrapper:      ext === '.json' ? wrapper_require_json_template : wrapper_require_template,
        fsPath:       resolvedPath
      }));
    }
  });

  if (wrapper) {
    source = wrapper({
      path: path.relative(root, filePath),
      apiPath: apiPath,
      source:  source,
      dependencies: dependencies
    });
  }

  result.push(source);

  return result.join('\n');
}


// Wraps all of the given files for in-browser use and writes the result into
// the destination filepath. `files` should be an array of Pathname objects
// taken from `client` section of a package.
function browserifyFiles(sandbox, pkgName, lookup, destination) {
  var result     = [];

  // Write module definitions.
  findPaths(lookup, function (fsPath, apiPath) {
    result.push(browserifySingle(sandbox, pkgName, fs.readFileSync(fsPath, 'utf8'), {
      wrapper:      wrapper_widget_template,
      fsPath:       fsPath,
      apiPath:      apiPath
    }));
  });

  // Write the result to the destination.
  fstools.mkdirSync(path.dirname(destination));
  fs.writeFileSync(destination, result.join('\n'), 'utf8');
}


//
// Check if the same file was included in multiple modules.
//
function reportRepeatedFiles(sandbox) {
  var relPath,
      includedInModules = {};

  Object.keys(embeddedModulesPaths).forEach(function (mod) {
    Object.keys(embeddedModulesPaths[mod]).forEach(function (file) {
      if (!includedInModules[file]) {
        includedInModules[file] = [];
      }

      includedInModules[file].push(mod);
    });
  });

  Object.keys(includedInModules).forEach(function (file) {
    if (includedInModules[file].length > 1) {
      relPath = path.relative(sandbox.N.mainApp.root, file);
      sandbox.N.logger.debug('File %s included in multiple modules: %s', relPath, includedInModules[file].join(', '));
    }
  });
}


////////////////////////////////////////////////////////////////////////////////


module.exports = function (sandbox) {
  var N      = sandbox.N,
      timer  = stopwatch(),
      tmpdir = sandbox.tmpdir,
      root   = N.mainApp.root;


  //
  // Collect flat lists of all `vendor` and `client` files from all packages.
  //

  vendorModules = {};
  clientModules = {};
  vendorVirtualModules = {};
  embeddedModulesPaths = {};

  _.forEach(sandbox.config.packages, function (pkg) {
    _.forEach(pkg.vendor[''], function (filePath) {
      vendorModules[filePath] = true;
    });
  });

  _.forEach(sandbox.config.packages, function (pkg) {
    findPaths(pkg.client, function (filePath) {
      clientModules[filePath] = true;
    });
  });

  _.forEach(sandbox.config.packages, function (pkg) {
    _.forEach(pkg.vendor, function (filePath, name) {
      if (name) {
        vendorVirtualModules[name] = filePath;
      }
    });
  });


  //
  // Build vendor files for each package
  //

  _.forEach(sandbox.config.packages, function (pkgConfig, pkgName) {
    var outfile = path.join(sandbox.tmpdir, 'vendor', pkgName + '.js'),
        result  = [];

    _.forEach(pkgConfig.vendor[''], function (fsPath) {

      var ext = path.extname(fsPath).toLowerCase();

      result.push(browserifySingle(sandbox, pkgName, fs.readFileSync(fsPath, 'utf8'), {
          wrapper:      ext === '.json' ? wrapper_require_json_template : wrapper_require_template,
          fsPath:       fsPath
        }));
    });

    _.forEach(pkgConfig.vendor, function (file, name) {
      if (name === '') { return; }
      result.push(wrapper_alias_template({
        name: name,
        path: path.relative(root, file)
      }));
    });

    fstools.mkdirSync(path.dirname(outfile));
    fs.writeFileSync(outfile, result.join('\n'), 'utf8');
  });

  N.logger.info('Processed vendor section %s', timer.elapsed);
  timer  = stopwatch();


  //
  // Build client files for each package
  //

  _.keys(sandbox.config.packages).forEach(function (pkgName) {
    var clientConfig = sandbox.config.packages[pkgName].client,
        mainLookup   = null,
        resultFile   = path.join(tmpdir, 'client', pkgName + '.js'),
        clientTmpDir = path.join(tmpdir, 'client', pkgName),
        mainFile     = path.join(clientTmpDir, 'main.js'),
        modulesFile  = path.join(clientTmpDir, 'client.js'),
        targetFile   = null, // mainFile if exists; modulesFile otherwise.
        environment  = sandbox.assets.environment,
        originPaths  = environment.paths, // to restore it later
        pkgTimer     = stopwatch();

    if (_.isEmpty(clientConfig)) {
      return;
    }

    mainLookup = _.find(clientConfig, 'main');

    if (mainLookup) {
      var tmp = fs.readFileSync(path.resolve(mainLookup.root, mainLookup.main));
      fstools.mkdirSync(path.dirname(mainFile));
      fs.writeFileSync(mainFile, tmp);
      targetFile = mainFile;
    } else {
      targetFile = modulesFile;
    }

    browserifyFiles(sandbox, pkgName, clientConfig, modulesFile);

    // Prepend path with `modulesFile` to allow use
    //
    //    //= require client
    //
    // in main file.
    environment.prependPath(clientTmpDir);

    // When Mincer is asked for a main file, it must be within roots, that
    // Mincer knows about. See: https://github.com/nodeca/mincer/issues/51
    clientConfig.forEach(function (options) {
      environment.appendPath(options.root);
    });

    // Find & build asset
    var asset = environment.findAsset(targetFile);

    // Check that main file is requirable.
    if (!asset) {
      // Restore Mincer's paths.
      environment.clearPaths();
      environment.appendPath(originPaths);

      throw new Error('Main client file of ' + pkgName + ' not found: ' + targetFile);
    }

    var source = asset.buffer.toString();

    fs.writeFileSync(resultFile, source, 'utf8');

    // Restore Mincer's paths.
    environment.clearPaths();
    environment.appendPath(originPaths);

    N.logger.debug('Compiled client of %s %s', pkgName, pkgTimer.elapsed);
    fstools.removeSync(clientTmpDir);
  });

  reportRepeatedFiles(sandbox);

  N.logger.info('Processed client section %s', timer.elapsed);
};
