//= require modernizr.custom
//= require yepnope
//= require_self


/*jshint browser:true,node:false*/
/*global yepnope, nodeca*/


(function () {
  'use strict';


  var toString  = Object.prototype.toString,
      hasOwn    = Object.prototype.hasOwnProperty;


  // check if `obj` is a function
  function isFunction(obj) {
    return '[object Function]' === toString.call(obj);
  }


  // check if `obj` is array
  function isArray(obj) {
    return '[object Array]' === toString.call(obj);
  }


  // check if `obj` is a plain object: not a null, underfined, function, array
  // or instance of something else.
  function isPlainObject(obj) {
    // Must be an Object.
    // Because of IE, we also have to check the presence of the constructor property.
    if (!obj || '[object Object]' !== toString.call(obj)) {
      return false;
    }

    try {
      // Not own constructor property must be Object
      if (obj.constructor &&
        !hasOwn.call(obj, "constructor") &&
        !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
    } catch ( e ) {
      // IE8,9 Will throw exceptions on certain host objects #9897
      return false;
    }

    // Own properties are enumerated firstly, so to speed up,
    // if last one is own, then all properties are own.

    /*jshint noempty:false*/
    for (var key in obj) {}

    return key === undefined || hasOwn.call(obj, key);
  }


  // Simple `each` iterator for `Objects`
  function each(obj, iter) {
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        iter(obj[k], k);
      }
    }
  }


  // Simple cross-browser `forEach` iterator for `Arrays`
  function forEach(arr, iter) {
    var i, l;

    for (i = 0, l = arr.length; i < l; i++) {
      iter(arr[i], i);
    }
  }


  // cached non-operable function
  function noop() {}


  // assets map for namespaces only - set with load_assets.init()
  var assets;


  function load_assets(namespace, callback) {
    var resources = [];


    if (!assets[namespace] || !!assets[namespace].loaded) {
      (callback || noop)();
      return;
    }

    resources = resources.concat(assets[namespace].css || []);
    resources = resources.concat(assets[namespace].js || []);

    yepnope({
      load:     resources,
      complete: function () {
        assets[namespace].loaded = true;
        (callback || noop)();
      }
    });
  }


  // internal helper used by load_assets,init that loads resources and fires
  // callback only once all resources were injected.
  function load_resources(resources, callback) {
    var i, count = resources.length;

    // fired once all queued scripts were injected
    function complete() {
      count--;

      if (0 === count) {
        callback();
      }
    }

    // assign complete calback for each resource object
    for (i = 0; i < count; i++) {
      resources[i].complete = complete;
    }

    // queue resources
    yepnope(resources);
  }


  // loads all necessary shims and libraries and assets for given namespace
  load_assets.init = function (assetsMap, namespace) {
    var resources = [], namespaces;

    // set internal assets map
    assets = assetsMap;

    // init can be called only once
    delete load_assets.init;

    // set list of requried namespaces
    namespaces = 'admin' === namespace ? [namespace] : ['common', namespace];

    // FIXME: `lib` namespace is a *special case* namespace
    //        and will be removed once it will be possible to
    //        bundle it into admin/common app.js
    namespaces.unshift('lib');

    //
    // Fill resources with shims and polyfills
    //

    resources.push({
      //  JSON is required for Opera < 11 + IE < 8
      //  See: http://caniuse.com/json
      test: !!window.JSON,
      nope: <%- JSON.stringify(asset_path('json2.js')) %>
    });

    //
    // Add resource with assets of required namespaces
    //

    forEach(namespaces, function (ns) {
      if (assets[ns] && assets[ns].js && assets[ns].js.length) {
        resources.push({ load: assets[ns].js });
      }
    });

    //
    // Queue assets injections
    //

    load_resources(resources, function () {
      forEach(namespaces, function (ns) {
        if (assets[ns]) {
          assets[ns].loaded = true;

          if (nodeca.client[ns] && isFunction(nodeca.client[ns].init)) {
            nodeca.client[ns].init();
          }
        }
      });
    });
  };


  function inject_tree(tree, branch) {
    // make sure tree is a plain object or a function
    tree = (isPlainObject(tree) || isFunction(tree)) && tree || {};

    each(branch || {}, function (val, key) {
      if (0 <= key.indexOf('.')) {
        // merg in `{"foo.bar.baz": {}}` trees
        var parts = key.split('.'), parent = parts.shift(), childs = {};
        childs[parts.join('.')] = val;
        tree[parent] = inject_tree(tree[parent], childs);
        return;
      }

      if (isPlainObject(val)) {
        tree[key] = inject_tree(tree[key], val);
        return;
      }

      if (isFunction(val)) {
        tree[key] = inject_tree(val, inject_tree(tree[key], val));
        return;
      }

      // plain value - do not try to merge - just override
      tree[key] = val;
    });

    // Return the modified object
    return tree;
  }


  window.load_assets = load_assets;
  window.inject_tree = inject_tree;
}());

// vim: filetype=javascript:syntax=javascript
