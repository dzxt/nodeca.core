/*global window, nodeca*/

//= require_self
//= require_tree ./nodeca

var nodeca = window.nodeca = (function (nodeca) {
  'use strict';

  nodeca.views            = {};
  nodeca.server           = {};
  nodeca.shared           = {};
  nodeca.client           = {};

  nodeca.runtime          = JSON.parse($('meta[name="csrf-param"]').attr('content'));
  nodeca.runtime.env      = "<%= nodeca('runtime.env') %>";
  nodeca.runtime.version  = "<%= nodeca('runtime.version') %>";
  nodeca.runtime.router   = new Pointer();
  nodeca.runtime.i18n     = new BabelFish({});

  // translations injector
  nodeca.runtime.i18n.load = function loadTranslations(lang, data) {
    if (undefined === nodeca.runtime.i18n._storage[lang]) {
      nodeca.runtime.i18n._storage[lang] = {};
    }

    $.extend(nodeca.runtime.i18n._storage[lang], data);
  };

  // translation helper with active locale
  nodeca.runtime.t        = function (phrase, params) {
    return nodeca.runtime.i18n.t(nodeca.runtime.locale, phrase, params);
  };

  nodeca.runtime.t.exists = function (phrase) {
    return nodeca.runtime.i18n.hasTranslation(nodeca.runtime.locale, phrase);
  };

  (function (c) {
    var log = c.log || $.noop;

    nodeca.logger = {};

    _.each(['assert', 'error', 'info', 'debug'], function (level) {
      // we deal with IE6-7 where no console exist at all
      // or we deal with IE8 where console.log or whatever might be an object
      if (!_.isFunction(c[level])) {
        c[level]= function () {
          log([level].concat(_.toArray(arguments)));
        };
      }

      // logger is now a function for sure, so we can safely bind a console
      // context, which is needed for Chrome
      nodeca.logger[level] = function () {
        c[level].apply(c, arguments);
      };
    });
  }(window.console || {}));

  // fill in routes
  _.each(<%- jason(nodeca('runtime.client_routes')) %>, function (v) {
    nodeca.runtime.router.addRoute(v[0], v[1]);
  });

  return nodeca;
}({}));

// vim: syntax=javascript
