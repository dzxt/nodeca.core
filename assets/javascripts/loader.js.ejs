//= require vendor/modernizr.custom
//= require vendor/yepnope
//= require_self


/*global yepnope*/


var loadAssets = window.loadAssets = (function () {
  'use strict';


  // assets map for namespaces only - set with loadAssets.init()
  var assets;


  // hash that keeps track on loaded assets
  var loaded = {};


  // check if `obj` is a function
  function isFunction(obj) {
    return '[object Function]' === Object.prototype.toString.call(obj);
  }


  // Simple cross-browser `forEach` iterator for `Arrays`
  function forEach(arr, iter) {
    var i, l;

    for (i = 0, l = arr.length; i < l; i++) {
      iter(arr[i], i);
    }
  }


  // cached non-operable function
  function noop() {}


  // helper that reports about unknown namespace
  function unknownNamespaceError(namespace) {
    alert("namespace " + namespace + " has no resources");
  }


  function loadAssets(namespace, callback) {
    var resources = [];

    callback = callback || noop;

    if (!assets[namespace]) {
      unknownNamespaceError(namespace);
      callback();
      return;
    }

    if (assets[namespace].css && !loaded[assets[namespace].css]) {
      resources.push(assets[namespace].css);
    }

    if (assets[namespace].js && !loaded[assets[namespace].js]) {
      resources.push(assets[namespace].js);
    }

    if (!resources.length) {
      callback();
      return;
    }

    yepnope({
      load:     resources,
      complete: function () {
        forEach(resources, function (res) {
          loaded[res] = true;
        });

        callback();
      }
    });
  }


  // internal helper used by loadAssets.init() that loads resources and fires
  // callback only once all resources were injected.
  function loadResources(resources, callback) {
    var i, count = resources.length;

    // fired once all queued scripts were injected
    function complete() {
      count--;

      if (0 === count) {
        callback();
      }
    }

    // assign complete calback for each resource object
    for (i = 0; i < count; i++) {
      resources[i].complete = complete;
    }

    // queue resources
    yepnope(resources);
  }


  // loads all necessary shims and libraries and assets for given namespace
  loadAssets.init = function init(assetsMap, namespace) {
    var resources = [];

    // set internal assets map
    assets = assetsMap;

    // init can be called only once
    loadAssets.init = noop;

    //
    // Fill resources with shims and polyfills
    //

    resources.push({
      //  JSON is required for Opera < 11 + IE < 8
      //  See: http://caniuse.com/json
      test: !!window.JSON,
      nope: <%- JSON.stringify(asset_path('vendor/json2.js')) %>
    });

    //
    // Make sure required namespace has resources
    //

    if (!assets[namespace]) {
      unknownNamespaceError(namespace);
      return;
    }

    //
    // Notify that initial assets were loaded.
    // CSS files must be explicitly loaded within layout.
    //

    if (assets[namespace].css) {
      loaded[assets[namespace].css] = true;
    }

    if (assets[namespace].js) {
      loaded[assets[namespace].js] = true;

      forEach(assets[namespace].load, function (pkgName) {
        resources.push({ load: assets[pkgName].js });
      });
    }

    //
    // Queue assets injections
    //

    loadResources(resources, function () {
      N.emit('init_complete');
    });
  };


  return loadAssets;
}());


// vim: filetype=javascript:syntax=javascript
